model Metro

enum Sentido {
    Ascendente,
    Descendente
}

class Reloj --CARMEN
attributes
    NOW:Integer init = 0 -- Minutos
operations
    tick()  --Propaga tick a estacion.
        begin
            self.NOW:=self.NOW+1;
            for e in Estacion.allInstances do
                e.tick()
            end
        end
constraints
    inv OneClock:
        Reloj.allInstances() -> 
        size() = 1
    inv ValidTime:
        NOW <> null
    -- Todas las fechas tienen que ser pasadas, no podemos tener fechas en el futuro
    inv TimeNotFuture:
        Parada.allInstances->forAll(p | p.llegada <= self.NOW) and
        Cruzar.allInstances->forAll(c | c.llegada <= self.NOW)
statemachines
    psm Reloj
        states
            s:initial
            tiempo
        transitions
            s->tiempo{create}
            tiempo->tiempo{tick()}
    end
end

class Linea --CARMEN
operations
    cabezaDeLinea():Estacion = self.estacion->first()
    finalDeLinea():Estacion = self.estacion->last()
     -- Siguiente en el orden ascendente normal
    siguiente(estacion:Estacion):Estacion = 
        let index = self.estacion -> indexOf(estacion)
        in self.estacion->at(index + 1)
    
    anterior(estacion:Estacion):Estacion = -- Anterior en el orden ascendente normal
        let index = self.estacion -> indexOf(estacion)
        in self.estacion->at(index - 1)
end

class Segmento --FRAN
operations
    tick() -- Propaga un tick de tiempo a las vías que tienen trenes a punto de salir
        begin
            declare t: Tren;
            declare sigestacion: Estacion;
            for v in (self.vias->select(v | v.proximaSalida() <> null)) do
                v.tick();
                v.saleTren();
                t:=v.proximaSalida();
                if (t.linea.estacion->indexOf(self.estacion->asSequence()->at(1)) > t.linea.estacion->indexOf(self.estacion->asSequence()->at(2))) then
                    t.llegaEstacion(self.estacion->asSequence()->at(1));  
                else
                    t.llegaEstacion(self.estacion->asSequence()->at(2));
                end;
                
            end;
        end
constraints
    inv OneLine:
        -- Todos los segmentos
        Segmento.allInstances() -> 
        -- Los segmentos conectan las mismas dos estaciones
        select(x| self.estacion = x.estacion) ->
        -- Los segmentos tienen la mismas líneas
        select(x| self.linea = x.linea) ->
        -- Solo puede haber un segmento
        size() = 1
    -- Las vías de un segmento tienen que ser de sentidos contrarios
    inv DistintosSentidosVias:
        self.vias->asSequence()->at(1).sentido <> self.vias->asSequence()->at(2).sentido
end

class Estacion --JOTA
attributes
    tiempoParada:Integer init = 1 -- 1 minuto de parada
operations
    proximaSalida():Set(Tren) = self.tren->select(t | (t.parada.llegada + tiempoParada >= self.reloj.NOW))
                                        ->select(t | not t.averiado)
                                        ->select(t | t.siguienteVia().estaVacio())
                                        
    estaVacio():Boolean = self.tren->isEmpty()
    tick() --Propaga un tick de tiempo a los segmentos y trenes parados
        begin
            for s in self.segmento do --Propaga un tick de reloj a los segmentos para que ellos los propaguen a los trenes que se encuentran en ellos.
                s.tick();
            end;

            for t in self.proximaSalida() do --Para cada tren que puede salir:
                self.saleTren(t);
            end;
        end
        post algunoHabraSalidoSiHabiaTrenesOperativos: (self@pre.proximaSalida()->notEmpty()) implies (self.proximaSalida() <> self@pre.proximaSalida())
    llegaTren(t:Tren)
        begin
            insert(self,t) into Parada
        end
        pre noEstaEnEstacion: t.enMovimiento()
        pre estaEnViaConectadaALaEstacion: --TO DO
        pre llegaATiempo: --TO DO
        post estaEnEstacion: not t.enMovimiento() and self.tren->includes(t)
    saleTren(t:Tren)
        begin
            t.saleEstacion(t.siguienteVia()) --HACER OPERACION t.siguienteVia()!!!!!
        end
        pre enEstacion: self.tren->includes(t)
        pre siguienteViaVacia: t.siguienteVia().estaVacio()
        pre noRoto: not t.averiado
        post noEnEstacion: self.tren->excludes(t)
        post viaOcupada: not t.siguienteVia().estaVacio()
constraints
statemachines
psm Estacion
    states
        s:initial
        vacio[self.estaVacio()]
        ocupado[not self.estaVacio()]
    transitions
        s->vacio{create}
        vacio->ocupado{llegaTren()}
        ocupado->vacio{saleTren()}
        ocupado->ocupado{saleTren()}
    end
end

class Via --ALTAIR
attributes
    sentido:Sentido
    tiempoRecorrido:Integer init = 2 -- Dos minutos entre estaciones
operations
    -- Devuelve si esta via está vacío o no
    estaVacio():Boolean = self.tren->isEmpty()
    -- Devuelve las líneas con las que está relacionada esta vía
    lineas():Set(Linea) = self.segmento.linea
    -- Devuelve el proximo tren que saldrá, o null si no hay tren o todavía no ha llegado al final
    -- (similar a un peek)
    proximaSalida():Tren = if cruzar.llegada + tiempoRecorrido >= Reloj.allInstances() -> any(true).NOW 
        then self.tren
        else null
        endif
    -- El tren recibido como parámetro llega a la vía y se añade (push)
    llegaTren(t:Tren)
        begin
            insert(self,t) into Cruzar;
        end
        pre libre: estaVacio()
        pre mismoSentido: self.sentido = t.sentido
        pre trenSinConectar: t.estacion -> isEmpty() and t.via -> isEmpty()
        pre noAveriado: not t.averiado
        post: not estaVacio()
    -- Se elimina el tren almacenado y se devuelve como resultado de la operación (pop)
    saleTren():Tren
        begin
            result:=self.tren;
            delete (self,self.tren) from Cruzar;
        end
        pre estaOcupado: not estaVacio()
        pre noTeletransporte: proximaSalida() <> null
        post libre: estaVacio()
constraints
    inv sentidoValido: sentido <> null
    inv tiempoValido: tiempoRecorrido >= 0
    inv mismoSentido: self.sentido = self.tren.sentido
statemachines 
psm Via
    states
        s:initial -- Estado inicial
        vacio[self.estaVacio()] --Vacio, se pone funcion estaVacio() que posteriormente haremos.
        ocupado[not self.estaVacio() ] --...
        --f:final opcional
    transitions
        s->vacio{create} --De s transiciona a vacío en el momento de su creación.
        vacio->ocupado{llegaTren()}
        ocupado->vacio{saleTren()}
    end
end

class Tren --CARLOS
attributes
    sentido:Sentido
    averiado:Boolean init = false
operations
    siguienteVia()
    enEstacion():Boolean = self.estacion->notEmpty()
    enMovimiento():Boolean = self.via->notEmpty()
    saleEstacion(v:Via)
        begin
            delete (self.estacion,self) from Parada;
            insert (v,self) into Cruzar;
        end
        pre mismoSentido: v.sentido = self.sentido
        pre mismaLinea: v.lineas()->includes(self.linea)
        pre viaVacia: v.estaVacio()
        pre noAveriado: not self.averiado
        pre enEstacion: self.enEstacion()
        pre estacionCorrespondeLinea: v.segmento.estacion->includes(self.estacion)
        post noEnEstacion: self.enMovimiento()
        post viaOcupada: not v.estaVacio()
    llegaEstacion(e:Estacion) --Lo contrario que sale estacion.
    averia() -- activar la averia del tren
    reparaTren() --desactivar la averia del tren
    darLaVuelta() --cambiar sentido del tren una vez se llega a final de línea
statemachines
psm Movimiento
    states
        s:initial
        enParada
        enTransito[self.enMovimiento()]
    transitions
        s->enParada{create}
        enParada->enTransito{saleEstacion()}
        enTransito->enParada{llegaEstacion()}
        enParada->enParada{darLaVuelta()}
    end
psm AveriasTren
    states
        s:initial
        disponible
        averiado
    transitions
        s->disponible{create}
        disponible->averiado{averia()}
        averiado->disponible{reparaTren()}
    end
end

aggregation Tiempo
between
    Estacion [*]
    Reloj [1]
end

association Estaciones
between
    Linea [1..*]
    Estacion [2..*] ordered
end

aggregation Segmentos
between
    Linea [1..*]
    Segmento [1..*]
end

association Salidas
between
    Segmento [1..*]
    Estacion [2]
end

associationclass Parada
between
    Estacion [0..1]
    Tren [*]
attributes
    -- El momento en el que llega a la estación
    llegada:Integer init = Reloj.allInstances() -> any(true).NOW
end

associationclass Cruzar
between
    Via [0..1]
    Tren [0..1]
attributes
    llegada:Integer init = Reloj.allInstances() -> any(true).NOW 
constraints
    inv llegadaValida: llegada <> null
end

composition Vias 
between
    Segmento [1]
    Via [2]
end

association Trenes
between
    Tren [*]
    Linea [1]
end

