model Metro

enum Sentido {
    Ascendente,
    Descendente
}

class Reloj
attributes
    NOW:Integer init = 0 -- Minutos
operations
    --Propaga tick a estacion.
    tick()  
        begin
            self.NOW:=self.NOW+1;
            for e in Estacion.allInstances do
                e.tick()
            end;
        end
        post: self.NOW@pre + 1 = self.NOW
    avanceRapido(ticks:Integer)
        begin
            for a in Sequence {1..ticks} do
                self.tick();
            end;
        end
        pre: ticks > 0
        post: self.NOW@pre + ticks = self.NOW
constraints
    inv OneClock:
        Reloj.allInstances()->size() = 1
    inv ValidTime:
        NOW <> null
    -- Todas las fechas tienen que ser pasadas, no podemos tener fechas en el futuro
    inv TimeNotFuture:
        Parada.allInstances()->forAll(p | p.llegada <= self.NOW) and
        Cruzar.allInstances()->forAll(c | c.llegada <= self.NOW)
statemachines
    psm Reloj
        states
            s:initial
            tiempo [self.NOW <> null]
        transitions
            s->tiempo {create}
            tiempo->tiempo {tick()}
    end
end

class Linea
operations
    cabezaDeLinea():Estacion = self.estacion->first()
    finalDeLinea():Estacion = self.estacion->last()
     -- Siguiente en el orden ascendente normal
    siguiente(estacion:Estacion):Estacion = 
        let index = self.estacion->indexOf(estacion)
        in self.estacion->at(index + 1)
    -- Anterior en el orden ascendente normal
    anterior(estacion:Estacion):Estacion = 
        let index = self.estacion->indexOf(estacion)
        in self.estacion->at(index - 1)

end

class Segmento
operations
    tick()
        begin
            for v in self.via->select(v | v.proximaSalida() <> null) do
                v.proximaSalida().llegaEstacion();
            end;
        end
constraints
    inv OneLine:
        -- Todos los segmentos
        Segmento.allInstances()-> 
        -- Los segmentos conectan las mismas dos estaciones
        select(x| self.estacion = x.estacion)->
        -- Los segmentos tienen la mismas líneas
        select(x| self.linea = x.linea)->
        -- Solo puede haber un segmento
        size() = 1
    -- Las vías de un segmento tienen que ser de sentidos contrarios
    inv DistintosSentidosVias:
        let seq = self.via->asSequence()
        in seq->at(1).sentido <> seq->at(2).sentido
end

class Estacion
attributes
    tiempoParada:Integer init = 1 -- 1 minuto de parada
operations
    proximaSalida():Set(Tren) = 
        self.tren->
        select(t | (self.reloj.NOW - t.parada.llegada >= tiempoParada))->
        select(t | not t.averiado)->
        select(t | t.siguienteVia().estaVacio())                        
    estaVacio():Boolean = self.tren->isEmpty()
    --Devuelve el numero de trenes que hay en la estacion
    cantidadTrenes(): Integer = self.tren->size()
    --Propaga un tick de tiempo a los segmentos y trenes parados
    tick() 
        begin
            --Propaga un tick de reloj a los segmentos para que ellos los propaguen a los trenes que se encuentran en ellos.
            for s in self.segmento do 
                s.tick();
            end;
            --Para cada tren que puede salir:
            for t in self.tren do 
                if self.proximaSalida() -> includes(t)
                then 
                    t.saleEstacion();
                end;
            end;
        end
        post algunoHabraSalidoSiHabiaTrenesOperativos: (self@pre.proximaSalida()->notEmpty()) implies (self.proximaSalida() <> self@pre.proximaSalida())
    llegaTren(t:Tren)
        begin
            insert(self,t) into Parada;
        end
        pre noEstaEnEstacion: t.enMovimiento()
        pre estaEnViaConectadaALaEstacion: self.segmento.via->includes(t.via) 
        pre puedeSalir: t.via.proximaSalida() = t
        post estaEnEstacion: self.tren->includes(t)
    adquirirTren(t:Tren)
        begin
            insert(self,t) into Parada;
        end
        pre mismaLinea: self.linea->includes(t.linea)
        pre noPerteneceAOtraEstacion: t.estacion->isEmpty()
        pre noPerteneceAOtraVia: t.via->isEmpty()
        post perteneceALaEstacion: t.estacion->notEmpty()
        post alMenosUnTrenEnEstacion: self.tren->notEmpty()
    saleTren(t:Tren)
        begin
            delete(self,t) from Parada;
        end
        pre enEstacion: self.tren->includes(t)
        pre noRoto: not t.averiado
        post noEnEstacion: self.tren->excludes(t)
constraints
statemachines
psm Estacion
    states
        s:initial
        vacio [self.estaVacio()]
        ocupado [not self.estaVacio()]
    transitions
        s->vacio {create}
        
        vacio->ocupado {llegaTren()}
        vacio->ocupado {adquirirTren()}
        
        ocupado->vacio {[self.cantidadTrenes() = 1] saleTren()}
        ocupado->ocupado {[self.cantidadTrenes() > 1] saleTren()}
        ocupado->ocupado {llegaTren()}
        ocupado->ocupado {adquirirTren()}
    end
end

class Via
attributes
    sentido:Sentido
    tiempoRecorrido:Integer init = 2 -- Dos minutos entre estaciones
operations
    -- Devuelve si esta via está vacío o no
    estaVacio():Boolean = self.tren->isEmpty()
    -- Devuelve las líneas con las que está relacionada esta vía
    lineas():Set(Linea) = self.segmento.linea
    -- Devuelve el proximo tren que saldrá, o null si no hay tren o todavía no ha llegado al final
    -- (similar a un peek)
    proximaSalida():Tren = if Reloj.allInstances()->any(true).NOW - cruzar.llegada >= tiempoRecorrido
        then self.tren 
        else null
        endif
    -- El tren recibido como parámetro llega a la vía y se añade (push)
    llegaTren(t:Tren)
        begin
            insert(self,t) into Cruzar;
        end
        pre libre: estaVacio()
        pre mismoSentido: self.sentido = t.sentido
        pre mismaLinea: self.lineas() -> includes(t.linea)
        pre noAveriado: not t.averiado
        post: not estaVacio()
    -- Se elimina el tren almacenado y se devuelve como resultado de la operación (pop)
    saleTren():Tren
        begin
            result:=self.tren;
            delete (self,self.tren) from Cruzar;
        end
        pre estaOcupado: not estaVacio()
        pre noTeletransporte: proximaSalida() <> null
        post libre: estaVacio()
constraints
    inv sentidoValido: sentido <> null
    inv tiempoValido: tiempoRecorrido >= 0
    inv mismoSentido: self.tren <> null implies self.sentido = self.tren.sentido
    inv mismaLinea: self.tren <>null implies self.lineas() -> includes(self.tren.linea)
statemachines 
psm Via
    states
        s:initial
        vacio [self.estaVacio()]
        ocupado [not self.estaVacio()] 
    transitions
        s->vacio {create} 
        vacio->ocupado {llegaTren()}
        ocupado->vacio {saleTren()}
    end
end

class Tren
attributes
    sentido:Sentido
    averiado:Boolean init = false
operations
    enEstacion():Boolean = self.estacion->notEmpty()
    enMovimiento():Boolean = self.via->notEmpty()
    siguienteEstacion():Estacion = 
        let 
            linea = self.linea,
            estaciones = self.via.segmento.estacion -> asSequence(),
            e1= estaciones->at(1),
            e2= estaciones->at(2)
        in
            if (linea.estacion -> indexOf(e1) > linea.estacion -> indexOf(e2) xor self.sentido = Sentido::Ascendente)
            then e2
            else e1
            endif

    siguienteVia(): Via =   
        if self.sentido = Sentido::Ascendente 
        then
            self.estacion.segmento->any(
                s | s.estacion->includes(self.linea.siguiente(self.estacion)) and s.linea->includes(self.linea)
            ).via->any(v | v.sentido = self.sentido)
        else
            self.estacion.segmento->any(
                s | s.estacion->includes(self.linea.anterior(self.estacion)) and s.linea->includes(self.linea)
                ).via->any(v | v.sentido = self.sentido)
        endif
    saleEstacion()
        begin
            declare v:Via;
            v:=siguienteVia();
            v.llegaTren(self);
            self.estacion.saleTren(self);
        end
        pre mismoSentido: siguienteVia().sentido = self.sentido
        pre mismaLinea: siguienteVia().lineas()->includes(self.linea)
        pre viaVacia: self.siguienteVia().estaVacio()
        pre noAveriado: not self.averiado
        pre enEstacion: self.enEstacion()
        pre estacionCorrespondeLinea: siguienteVia().segmento.estacion->includes(self.estacion)
        post noEnEstacion: self.enMovimiento()
        post viaOcupada: not self.via.estaVacio()
    llegaEstacion() 
        begin
            declare e:Estacion;
            e:= siguienteEstacion();
            e.llegaTren(self);
            self.via.saleTren();
            
            if self.estacion = self.linea.cabezaDeLinea() or self.estacion = self.linea.finalDeLinea()
            then
                self.darLaVuelta();
            end;
        end
        pre enVia: self.via->size() = 1
        pre viaConectaEstacion: self.via.segmento.estacion->includes(siguienteEstacion())
        post enEstacionOcupada: self.enEstacion() and not self.estacion.estaVacio()
    -- Activar la averia del tren
    averia()
        begin
            self.averiado := true
        end
        pre noEstaAveriado: not self.averiado
        post estaAveriado: self.averiado
    -- Desactivar la averia del tren
    reparaTren() 
        begin
            self.averiado := false
        end
        pre estaAveriado: self.averiado
        post noEstaAveriado: not self.averiado
    -- Cambiar sentido del tren una vez se llega a final de línea
    darLaVuelta()
        begin
            if self.sentido = Sentido::Ascendente then
                self.sentido := Sentido::Descendente
            else    
                self.sentido := Sentido::Ascendente
            end
        end 
        pre trenEnEstacion: self.enEstacion()
        pre enColaDeLinea: self.estacion.linea.cabezaDeLinea()->any(true) = self.estacion or
            self.estacion.linea.finalDeLinea()->any(true) = self.estacion 
        post cambiaSentido: self.sentido <> self.sentido@pre

statemachines
psm Movimiento
    states
        s:initial
        enParada 
        enTransito [self.enMovimiento()]
    transitions
        s->enParada {create}
        enParada->enTransito {saleEstacion()}
        enTransito->enParada {llegaEstacion()}
        enParada->enParada {darLaVuelta()}
    end
psm AveriasTren
    states
        s:initial
        disponible [self.averiado = false]
        averiado [self.averiado = true]
    transitions
        s->disponible {create}
        disponible->averiado {averia()}
        averiado->disponible {reparaTren()}
    end
end

aggregation Tiempo
between
    Estacion [*]
    Reloj [1]
end

association Estaciones
between
    Linea [1..*]
    Estacion [2..*] ordered
end

aggregation Segmentos
between
    Linea [1..*]
    Segmento [1..*]
end

association Salidas
between
    Segmento [1..*]
    Estacion [2]
end

associationclass Parada
between
    Estacion [0..1]
    Tren [*]
attributes
    -- El momento en el que llega a la estación
    llegada:Integer init = Reloj.allInstances() -> any(true).NOW
end

associationclass Cruzar
between
    Via [0..1]
    Tren [0..1]
attributes
    llegada:Integer init = Reloj.allInstances() -> any(true).NOW 
constraints
    inv llegadaValida: llegada <> null
end

composition Vias 
between
    Segmento [1]
    Via [2]
end

association Trenes
between
    Tren [*]
    Linea [1]
end

