---
# PANDOC_IMPORTANT: Use pandoc-include-code and mermaid-filter
# Note: Requires Arial font to be installed on your system
title: P4
author:
  - "Francisco Javier Hernández Martín"
  - "Jose Luis Bueno Pachón"
  - "Carlos Marín Corbera"
  - "Carmen González Ortega"
  - "Altair Bueno Calvente"
date: 15 jan 2022
keywords:
  - Modelado
  - P4
  - Java
titlepage: true
titlepage-rule-color: "B17560"
logo: ./resources/uma.png
toc-own-page: true
toc: true
mainfont: Arial
header-includes:
  - \usepackage{fvextra}
  - \DefineVerbatimEnvironment{Highlighting}{Verbatim}{breaklines,commandchars=\\\{\}}
---

<!--Anotaciones de pie de página-->

[^1]: https://google.github.io/styleguide/javaguide.html
[^2]: https://en.wikipedia.org/wiki/Eiffel_(programming_language)#Scoping
[^3]: https://junit.org/junit5/


<!-- Document start-->

# Preámbulo

Para la realización de esta práctica, hemos optado por utilizar un estilo de
programación estandarizado para el lenguaje de programación Java, conocido como
**Google Java Style Guide**[^1]. Además, para verificar el correcto
funcionamiento de la implementación de los distintos ejercicios, hemos creado
una serie de test unitarios usando el framework de pruebas **jUnit5**[^3].

# Ejercicio 1: Los interfaces selectivos

## Apartado A

En Java contamos con los **modificadores de acceso** para exportar de forma
selectiva las distintas clases y atributos del sistema. Por ejemplo, para crear
una clase `Foo` con visibilidad pública escribimos lo siguiente:

```
// Modificador de acceso público
// vvv
public class Foo {/* ... */}
```

En Java, los distintos modificadores de acceso son:

- **Visibilidad privada (`private`)**: Es la visibilidad más restrictiva. El
  elemento marcado con el atributo `private` será solo visible desde la clase en
  la que se declara.
- **Visibilidad de paquete**: Es la visibilidad por defecto de Java. Aquellos
  elementos que no han sido explícitamente marcados serán considerados visibles
  desde el paquete. Esto significa que el elemento se comporta con visibilidad
  pública en aquellas clases del mismo paquete, pero de forma privada con las
  clases externas al paquete.
- **Visibilidad protegida (`protected`)**: Al igual que la visibilidad de
  paquete, la visibilidad protegida impide que las clases externas accedan a
  aquellos elementos marcados con el atributo `protected`, aunque permite a sus
  subclases y clases del mismo paquete acceder a dichos elementos.
- **Visibilidad pública (`public`)**: Permite que el elemento marcado con el
  atributo `public` sea visible desde cualquier clase.

En la siguiente tabla se resumen las características principales de las
distintas visibilidades de Java:

| Modificador | Misma clase | Mismo paquete | Distinto paquete, subclase | Distinto paquete |
| ----------- | ----------- | ------------- | -------------------------- | ---------------- |
| Privado     | Sí          | No            | No                         | No               |
| De paquete  | Sí          | Sí            | No                         | No               |
| Protegido   | Sí          | Sí            | Sí                         | No               |
| Público     | Sí          | Sí            | Sí                         | Sí               |

Por otra parte, el lenguaje Eiffel profundiza más en el mecanismo de exportación
selectiva, otorgando al programador de un control granular sobre el acceso a los
elementos de las clases. Los distintos modificadores de acceso Eiffel, según
Wikipedia[^2], son:

- **Visibilidad pública (`feature`)**: Al igual que en Java, permite que sea
  visible desde cualquier clase.
- **Visibilidad protegida (`feature {}`)**: Al igual que en Java, permite que
  sea visible desde sus subclases y clases del mismo paquete.
- **Visibilidad _selectiva_ (`feature {class1,class2,class3...}`)**: Permite que
  dicho elemento sea visible a las clases seleccionadas, actuando como privada
  para las demás clases.

Podemos observar que ambos lenguajes tienen distintos modificadores de acceso;
Java incluye visibilidad **privada** y **de paquete**, mientras que Eiffel
incluye **_selectiva_**, siendo esta última un preciso que las demás
visibilidades. También se puede diferenciar entre ambos lenguajes según su
metodología para controlar el acceso: los modificadores de acceso de Java
dependen del rango o alcance (misma clase, subclases, paquete, fuera del
paquete...) y los modificadores de Eiffel dependen de quién intente acceder a
ese elemento/característica.

## Apartado B

![Patrón Proxy](models/Ej1.svg)

Para poder emular el mecanismo de exportación selectiva de Eiffel, debemos
controlar el acceso al servicio (la clase X) y para ello utilizamos el Patrón
**Representante** o **Proxy** y el Patrón **Envoltorio** o **Wrapper**.

En el paquete llamado **X** se encuentran las siguientes clases:

- `XInterface`
- `XService`
- `XProxy`

La clase abstracta `XInterface`, como debe permitir operaciones de visibilidad
protegida, no puede ser una Interfaz, así que hemos decidido modelar el mismo
comportamiento mediante una clase abstracta. Las dos clases que la implementan
son `XProxy` (encargada de controlar el acceso) y `XService` (encargada de
ofrecer el servicio), siendo esta clase la que denominan 'X' en el enunciado 
de la práctica. La clase `XProxy` se encargará de verificar si el cliente 
cuenta con los permisos suficientes para poder realizar dicha llamada, y en 
caso contrario, lanzará una excepción de tipo `IllegalCallerException`.

Las clases `A`, `B` y `C` heredan de la clase `Cliente` y se encontrarán en 
otro paquete para proteger el acceso a los métodos de `XService`, teniendo así 
una referencia únicamente a la clase `XProxy`, a diferencia del patrón 
**Representante** donde debería interactuar el cliente con la interfaz. Esto 
implica que la clase `XProxy` actúe a su vez como una clase envoltorio, por lo 
que se ha aplicado el patrón **Envoltorio** de esta manera. El método `rutina1`
será visible para todos, los métodos `rutina2` y `rutina3` serán visibles desde
el exterior, pero su ejecución solo será satisfactoria en caso de que el 
cliente cumpla los requisitos establecidos. Por último, el método `rutina4` 
será solo accesible desde las subclases.

La ventaja que nos proporciona aplicar este Patrón es que los clientes
no interactúan directamente con `XService`, relegando el control del acceso
a la clase `XProxy` y dejando que `XService` únicamente se encargue de aplicar
los métodos. La desventaja que podemos observar es que al no existir soporte en
Java para el control granular de permisos, el acceso se comprueba en tiempo de
ejecución en vez de en tiempo de compilación.

# Ejercicio 2: Triestables

# Ejercicio 3: Cliente de correo e-look

# Código Java
## Ej1

### `A.java`

```{include=src/main/java/Ej1/A.java}
```

### `B.java`

```{include=src/main/java/Ej1/B.java}
```

### `C.java`

```{include=src/main/java/Ej1/C.java}
```

### `Client.java`

```{include=src/main/java/Ej1/Client.java}
```


### `XInterface.java`

```{include=src/main/java/Ej1/x/XInterface.java}
```

### `XProxy.java`

```{include=src/main/java/Ej1/x/XProxy.java}
```

### `XService.java`

```{include=src/main/java/Ej1/x/XService.java}
```

## Ej2

### `Amarillo.java`

```{include=src/main/java/Ej2/b/Amarillo.java}
```

### `EstadoTriestable.java`

```{include=src/main/java/Ej2/b/EstadoTriestable.java}
```

### `Main.java`

```{include=src/main/java/Ej2/b/Main.java}
```

### `Mediador.java`

```{include=src/main/java/Ej2/b/Mediador.java}
```

### `MediadorConcreto.java`

```{include=src/main/java/Ej2/b/MediadorConcreto.java}
```

### `Rojo.java`

```{include=src/main/java/Ej2/b/Rojo.java}
```

### `Triestable.java`

```{include=src/main/java/Ej2/b/Triestable.java}
```

### `Verde.java`

```{include=src/main/java/Ej2/b/Verde.java}
```

## Ej3

### `DateSortStrategy.java`

```{include=src/main/java/Ej3/DateSortStrategy.java}
```

### `Email.java`

```{include=src/main/java/Ej3/Email.java}
```

### `FromSortStrategy.java`

```{include=src/main/java/Ej3/FromSortStrategy.java}
```

### `Mailbox.java`

```{include=src/main/java/Ej3/Mailbox.java}
```

### `Main.java`

```{include=src/main/java/Ej3/Main.java}
```

### `Priority.java`

```{include=src/main/java/Ej3/Priority.java}
```

### `PrioritySortStrategy.java`

```{include=src/main/java/Ej3/PrioritySortStrategy.java}
```

### `SortStrategy.java`

```{include=src/main/java/Ej3/SortStrategy.java}
```

### `SubjectSortStrategy.java`

```{include=src/main/java/Ej3/SubjectSortStrategy.java}
```

## JUnit

### `Ej1.java`

```{include=src/test/java/Ej1.java}
```

